#!/usr/bin/env ruby
# Lancher for Pupistry CLI

require 'rubygems'
require 'thor'
require 'logger'
require 'pupistry'

# Ensure all output is real time - this is a long running process with
# continual output, we want it to sync ASAP
STDOUT.sync = true

# Logging - STDOUT only
$logger = Logger.new(STDOUT)


# Thor is a toolkit for producing command line applications, see http://whatisthor.com/
class CLI < Thor
  class_option :verbose, :type => :boolean
  class_option :config, :type => :string


  ## Agent Commands
  
  desc "apply", "Apply the latest Puppet artifact"
  method_option :noop,        :type => :boolean, :desc => "No changes mode (note: does change checked out artifact, but no Puppet changes)"
  method_option :force,       :type => :boolean, :desc => "Ignore existing versions, re-apply every time"
  method_option :minimal,     :type => :boolean, :desc => "Don't run Puppet unless the artifact has changed"
  method_option :daemon,      :type => :boolean, :desc => "Run as a system daemon"
  method_option :environment, :type => :string,  :desc => "Specifiy which environment to deploy (default: master)"
  def apply

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Muppet Check
    if options[:noop] and options[:daemon]
      $logger.warn "A daemon running in noop will do nothing except log what changes it could apply"
    end

    # Muppet dev check
    if options[:daemon]
      $logger.fatal "Daemon mode not implemented yet"
      exit 0
    end


    # Fetch artifact versions
    $logger.info "Checking version of artifact available..."

    artifact = Pupistry::Artifact.new
    artifact.checksum = artifact.fetch_latest

    artifact_installed = Pupistry::Artifact.new
    artifact_installed.checksum = artifact_installed.fetch_installed


    # Download the new artifact if one has changed. If we already have this
    # version, then we should skip downloading and go straight to running
    # Puppet - unless the user runs with --force (eg to fix a corrupted
    # artifact).
    $logger.debug "Currently on #{artifact_installed.checksum}"
    
    if artifact.checksum != artifact_installed.checksum or options[:force]
      if options[:force]
        $logger.warn "Forcing download of latest artifact regardless of current one."
      end

      # Install the artifact
      $logger.info "Downloading latest artifact (#{artifact.checksum})..."

      artifact.fetch_artifact
      artifact.unpack

      unless artifact.install
        $logger.fatal "An unexpected error happened when installing the latest artifact, cancelling Puppet run"
        exit 0
      end

      # Remove temporary unpacked files
      artifact.clean_unpack
    else
      $logger.info "Already have latest artifact applied."

      # By default we run Puppet even if we have the latest artifact. There's
      # some grounds for debate about whether this is the right thing - in some
      # ways it is often a waste of CPU, since if the artifact hasn't changed,
      # then it's unlikley anything else has changed.
      #
      # But that's not always 100% true - Puppet will undo local changes or
      # upgrade package versions (ensure => latest) if appropiate, so we should
      # act like the standard command and attempt to apply whatever we can.
      #
      # To provide users with options, we provide the --lazy parameter to avoid
      # running Puppet except when the artifact changes. By default, Puppet
      # runs every thing to avoid surprise.
      
      if options[:minimal]
        $logger.info "Running with minimal effort mode enabled, not running Puppet since artifact version already applied"
        exit 0
      end

    end


    # Execute Puppet.
    puppet_cmd = "puppet apply"

    if options[:noop]
      puppet_cmd += " --noop"
    end

    if options[:environment]
      environment = options[:environment]
    else
      environment = 'master'
    end

    puppet_cmd += " --environment #{environment}"
    puppet_cmd += " --modulepath #{$config["agent"]["puppetcode"]}/#{environment}/modules/"
    puppet_cmd += " --hiera_config #{$config["agent"]["puppetcode"]}/#{environment}/hiera.yaml"
    puppet_cmd += " #{$config["agent"]["puppetcode"]}/#{environment}/manifests/site.pp"

    $logger.info "Executing Puppet..."
    $logger.debug "With: #{puppet_cmd}"

    unless system puppet_cmd
      $logger.fatal "An unexpected issue occured when running puppet"
    end

  end



  ## Workstation Commands

  desc "build", "Build a new archive file"
  def build

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end


    begin
      # Fetch the latest data with r10k
      artifact = Pupistry::Artifact.new

      artifact.fetch_r10k
      artifact.build_artifact

      puts "--"
      puts "Tip: Run pupistry diff to see what changed since the last artifact version"

    rescue Exception => e
      $logger.fatal "An unexpected error occured when trying to generate the new artifact file"
      raise e
    end

  end


  desc "diff", "Show what has changed between now and the current live artifact"
  def diff

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Fetch the latest artifact
    artifact_upstream          = Pupistry::Artifact.new
    artifact_upstream.checksum = artifact_upstream.fetch_latest

    unless artifact_upstream.checksum
      $logger.error "There is no upstream artifact to compare to."
      exit 0
    end

    artifact_upstream.fetch_artifact

    # Fetch the current artifact
    artifact_current          = Pupistry::Artifact.new
    artifact_current.checksum = artifact_current.fetch_current

    unless artifact_current.checksum
      $logger.error "There is no current artifact to compare to, run \"pupistry build\" first to generate one with current changes"
      exit 0
    end

    artifact_current.fetch_artifact

    # Unpack the archives
    artifact_current.unpack
    artifact_upstream.unpack

    # Diff the contents. This is actually bit of a pain, there's no native way
    # of diffing an entire directory and a lot of the gems out there that promise
    # to do diffing a) can't handle dirs and b) generally exec out to native diff
    # anyway. :-(
    #
    # So given this, we might as well go native and just rely on the system
    # diff command to do the job.
    
    Dir.chdir("#{$config["general"]["app_cache"]}/artifacts/") do
      unless system "diff -Nuar unpacked.#{artifact_upstream.checksum} unpacked.#{artifact_current.checksum}"
      end
    end


    # Cleanup
    artifact_current.clean_unpack
    artifact_upstream.clean_unpack

    puts "--"
    puts "Tip: Run pupistry push to GPG sign & upload if happy to go live"
  end


  desc "push", "Sign & Upload a new artifact version"
  def push

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Push the artifact to S3
    artifact = Pupistry::Artifact.new
    artifact.push_artifact
  end


  desc "bootstrap", "Generate a user-data bootstrap script for a node"
  method_option :template, :type => :string, :desc => 'The template you want to generate'
  method_option :base64, :type => :boolean, :desc => 'Output in base64 format'
  def bootstrap

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end


    if options[:template]
      $logger.info "Generating bootstrap template #{options[:template]}"

      templates = Pupistry::Bootstrap.new
      templates.build options[:template]

      if options[:base64]
        templates.output_base64
      else
        templates.output_plain
      end
    else
      templates = Pupistry::Bootstrap.new
      templates.list
     
      puts "--"
      puts "Tip: Run `pupistry bootstrap --template example` to generate a specific template"
    end
      
  end
end

CLI.start(ARGV)

# vim:shiftwidth=2:tabstop=2:softtabstop=2:expandtab:smartindent
