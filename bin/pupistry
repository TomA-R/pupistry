#!/usr/bin/env ruby
# Lancher for Pupistry CLI

require 'rubygems'
require 'thor'
require 'logger'
require 'pupistry'

# Ensure all output is real time - this is a long running process with
# continual output, we want it to sync ASAP
STDOUT.sync = true

# Logging - STDOUT only
$logger = Logger.new(STDOUT)


# Thor is a toolkit for producing command line applications, see http://whatisthor.com/
class CLI < Thor
  class_option :verbose, :type => :boolean
  class_option :config, :type => :string


  ## Agent Commands
  
  desc "apply", "Apply the latest Puppet artifact"
  method_option :noop, :type => :boolean
  method_option :daemon, :type => :boolean
  method_option :environment, :type => :string
  def apply

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Muppet Check
    if options[:noop] and options[:daemon]
      $logger.warn "A daemon running in noop will do nothing except log what changes it could apply"
    end

    # Muppet dev check
    if options[:daemon]
      $logger.fatal "Daemon mode not implemented yet"
      exit 0
    end

    # Install the artifact
    # TODO: Check if we've already installed it or not... :-)
    $logger.info "Pulling latest artifact...."

    artifact = Pupistry::Artifact.new
    artifact.checksum = artifact.fetch_latest
    artifact.fetch_artifact
    artifact.unpack
    unless artifact.install
      $logger.fatal "An unexpected error happened when installing the latest artifact, cancelling Puppet run"
      exit 0
    end

    # Remove temporary unpacked files
    artifact.clean_unpack


    # Execute Puppet. At this point
    puppet_cmd = "puppet apply"

    if options[:noop]
      puppet_cmd += " --noop"
    end

    if options[:environment]
      environment = options[:environment]
    else
      environment = 'master'
    end

    puppet_cmd += " --environment #{environment}"
    puppet_cmd += " --modulepath #{$config["agent"]["puppetcode"]}/#{environment}/modules/"
    puppet_cmd += " --hiera_config #{$config["agent"]["puppetcode"]}/#{environment}/hiera.yaml"
    puppet_cmd += " #{$config["agent"]["puppetcode"]}/#{environment}/manifests/site.pp"

    $logger.info "Executing Puppet..."
    $logger.debug "With: #{puppet_cmd}"

    unless system puppet_cmd
      $logger.fatal "An unexpected issue occured when running puppet"
    end

  end



  ## Workstation Commands

  desc "build", "Build a new archive file"
  def build

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end


    begin
      # Fetch the latest data with r10k
      artifact = Pupistry::Artifact.new

      artifact.fetch_r10k
      artifact.build_artifact

      puts "--"
      puts "Tip: Run pupistry diff to see what changed since the last artifact version"

    rescue Exception => e
      $logger.fatal "An unexpected error occured when trying to generate the new artifact file"
      raise e
    end

  end


  desc "diff", "Show what has changed between now and the current live artifact"
  def diff

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Fetch the latest artifact
    artifact_upstream          = Pupistry::Artifact.new
    artifact_upstream.checksum = artifact_upstream.fetch_latest

    unless artifact_upstream.checksum
      $logger.error "There is no upstream artifact to compare to."
      exit 0
    end

    artifact_upstream.fetch_artifact

    # Fetch the current artifact
    artifact_current          = Pupistry::Artifact.new
    artifact_current.checksum = artifact_current.fetch_current

    unless artifact_current.checksum
      $logger.error "There is no current artifact to compare to, run \"pupistry build\" first to generate one with current changes"
      exit 0
    end

    artifact_current.fetch_artifact

    # Unpack the archives
    artifact_current.unpack
    artifact_upstream.unpack

    # Diff the contents. This is actually bit of a pain, there's no native way
    # of diffing an entire directory and a lot of the gems out there that promise
    # to do diffing a) can't handle dirs and b) generally exec out to native diff
    # anyway. :-(
    #
    # So given this, we might as well go native and just rely on the system
    # diff command to do the job.
    
    Dir.chdir("#{$config["general"]["app_cache"]}/artifacts/") do
      unless system "diff -Nuar unpacked.#{artifact_upstream.checksum} unpacked.#{artifact_current.checksum}"
      end
    end


    # Cleanup
    artifact_current.clean_unpack
    artifact_upstream.clean_unpack

    puts "--"
    puts "Tip: Run pupistry push to GPG sign & upload if happy to go live"
  end


  desc "push", "Sign & Upload a new artifact version"
  def push

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end

    # Push the artifact to S3
    artifact = Pupistry::Artifact.new
    artifact.push_artifact
  end


  desc "bootstrap", "Generate a user-data bootstrap script for a node"
  method_option :template, :type => :string
  def bootstrap

    # Thor seems to force class options to be defined repeatedly? :-/
    if options[:verbose]
      $logger.level = Logger::DEBUG
    else
      $logger.level = Logger::INFO
    end

    if options[:config]
      Pupistry::Config.load(options[:config])
    else
      Pupistry::Config.find_and_load
    end


    if options[:template]
      $logger.info "Generating bootstrap template #{options[:template]}"
    else
      puts "Listing all avaible templates"
      Pupistry::Bootstrap.templates_list

      
    end
      
  end
end

CLI.start(ARGV)

# vim:shiftwidth=2:tabstop=2:softtabstop=2:expandtab:smartindent
